"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/extract-colors";
exports.ids = ["vendor-chunks/extract-colors"];
exports.modules = {

/***/ "(ssr)/./node_modules/extract-colors/lib/extract-colors.mjs":
/*!************************************************************!*\
  !*** ./node_modules/extract-colors/lib/extract-colors.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   extractColors: () => (/* binding */ extractColors),\n/* harmony export */   extractColorsFromImage: () => (/* binding */ extractColorsFromImage),\n/* harmony export */   extractColorsFromImageBitmap: () => (/* binding */ extractColorsFromImageBitmap),\n/* harmony export */   extractColorsFromImageData: () => (/* binding */ extractColorsFromImageData),\n/* harmony export */   extractColorsFromSrc: () => (/* binding */ extractColorsFromSrc)\n/* harmony export */ });\nconst EXTRACTOR_PIXELS_DEFAULT = 64e3;\nconst EXTRACTOR_DISTANCE_DEFAULT = 0.22;\nconst AVERAGE_HUE_DEFAULT = 1 / 12;\nconst AVERAGE_SATURATION_DEFAULT = 1 / 5;\nconst AVERAGE_LIGHTNESS_DEFAULT = 1 / 5;\nfunction testInputs({\n  pixels = EXTRACTOR_PIXELS_DEFAULT,\n  distance: distance2 = EXTRACTOR_DISTANCE_DEFAULT,\n  colorValidator = (_red, _green, _blue, _alpha) => (_alpha ?? 255) > 250,\n  hueDistance: hueDistance2 = AVERAGE_HUE_DEFAULT,\n  saturationDistance = AVERAGE_LIGHTNESS_DEFAULT,\n  lightnessDistance = AVERAGE_SATURATION_DEFAULT,\n  crossOrigin = \"\",\n  requestMode = \"cors\"\n} = {}) {\n  const testUint = (label, val, min = 0, max = Number.MAX_SAFE_INTEGER) => {\n    if (!Number.isInteger(val)) {\n      throw new Error(`${label} is not a valid number (${val})`);\n    }\n    if (val < min) {\n      console.warn(`${label} can not be less than ${min} (it's ${val})`);\n    }\n    if (val > max) {\n      console.warn(`${label} can not be more than ${max} (it's ${val})`);\n    }\n    return Math.min(Math.max(val, min), max);\n  };\n  const testNumber = (label, val, min = 0, max = Number.MAX_VALUE) => {\n    if (Number(val) !== val) {\n      throw new Error(`${label} is not a valid number (${val})`);\n    }\n    if (val < min) {\n      console.warn(`${label} can not be less than ${min} (it's ${val})`);\n    }\n    if (val > max) {\n      console.warn(`${label} can not be more than ${max} (it's ${val})`);\n    }\n    return Math.min(Math.max(val, min), max);\n  };\n  const testFunction = (label, val) => {\n    if (!val || {}.toString.call(val) !== \"[object Function]\") {\n      throw new Error(`${label} is not a function (${val})`);\n    }\n    return val;\n  };\n  const testValueInList = (label, val, list) => {\n    if (list.indexOf(val) < 0) {\n      console.warn(\n        `${label} can be one of this values ${list.map((v) => `\"${v}\"`).join(\", \")} (it's \"${val}\")`\n      );\n    }\n  };\n  testUint(\"pixels\", pixels || 0, 1);\n  testNumber(\"distance\", distance2, 0, 1);\n  testFunction(\"colorValidator\", colorValidator);\n  testNumber(\"hueDistance\", hueDistance2, 0, 1);\n  testNumber(\"saturationDistance\", saturationDistance, 0, 1);\n  testNumber(\"lightnessDistance\", lightnessDistance, 0, 1);\n  testValueInList(\"crossOrigin\", crossOrigin, [\n    \"\",\n    \"anonymous\",\n    \"use-credentials\"\n  ]);\n  testValueInList(\"requestMode\", requestMode, [\n    \"cors\",\n    \"navigate\",\n    \"no-cors\",\n    \"same-origin\"\n  ]);\n}\nconst cleanInputs = ({\n  pixels = EXTRACTOR_PIXELS_DEFAULT,\n  distance: distance2 = EXTRACTOR_DISTANCE_DEFAULT,\n  colorValidator = (_red, _green, _blue, _alpha) => (_alpha ?? 255) > 250,\n  hueDistance: hueDistance2 = AVERAGE_HUE_DEFAULT,\n  saturationDistance = AVERAGE_LIGHTNESS_DEFAULT,\n  lightnessDistance = AVERAGE_SATURATION_DEFAULT,\n  crossOrigin = \"\",\n  requestMode = \"cors\"\n} = {}) => {\n  return [\n    Math.max(pixels, 1),\n    Math.min(Math.max(distance2, 0), 1),\n    colorValidator,\n    Math.min(Math.max(hueDistance2, 0), 1),\n    Math.min(Math.max(saturationDistance, 0), 1),\n    Math.min(Math.max(lightnessDistance, 0), 1),\n    crossOrigin,\n    requestMode\n  ];\n};\nclass Color {\n  /**\n   * Set red, green and blue colors to create the Color object.\n   */\n  constructor(red, green, blue, hex = red << 16 | green << 8 | blue) {\n    this._count = 1;\n    this.__saturation = -1;\n    this.__hue = -1;\n    this.__lightness = -1;\n    this.__intensity = -1;\n    this._red = red;\n    this._green = green;\n    this._blue = blue;\n    this._hex = hex;\n  }\n  /**\n   * Distance between two colors.\n   * - Minimum is 0 (between two same colors)\n   * - Maximum is 1 (for example between black and white)\n   */\n  static distance(colorA, colorB) {\n    return (Math.abs(colorB._red - colorA._red) + Math.abs(colorB._green - colorA._green) + Math.abs(colorB._blue - colorA._blue)) / (3 * 255);\n  }\n  clone() {\n    const color = new Color(this._red, this._green, this._blue, this._hex);\n    color._count = this._count;\n    return color;\n  }\n  updateHSL() {\n    const red = this._red / 255;\n    const green = this._green / 255;\n    const blue = this._blue / 255;\n    const max = Math.max(red, green, blue);\n    const min = Math.min(red, green, blue);\n    this.__lightness = (max + min) / 2;\n    if (max === min) {\n      this.__hue = 0;\n      this.__saturation = 0;\n      this.__intensity = 0;\n    } else {\n      const distance2 = max - min;\n      this.__saturation = this.__lightness > 0.5 ? distance2 / (2 - max - min) : distance2 / (max + min);\n      this.__intensity = this.__saturation * ((0.5 - Math.abs(0.5 - this.__lightness)) * 2);\n      switch (max) {\n        case red:\n          this.__hue = ((green - blue) / distance2 + (green < blue ? 6 : 0)) / 6;\n          break;\n        case green:\n          this.__hue = ((blue - red) / distance2 + 2) / 6;\n          break;\n        case blue:\n          this.__hue = ((red - green) / distance2 + 4) / 6;\n          break;\n      }\n    }\n  }\n  /**\n   * Hue from 0 to 1\n   */\n  get _hue() {\n    if (this.__hue === -1) {\n      this.updateHSL();\n    }\n    return this.__hue;\n  }\n  /**\n   * Saturation from 0 to 1\n   */\n  get _saturation() {\n    if (this.__saturation === -1) {\n      this.updateHSL();\n    }\n    return this.__saturation;\n  }\n  /**\n   * Lightness from 0 to 1\n   */\n  get _lightness() {\n    if (this.__lightness === -1) {\n      this.updateHSL();\n    }\n    return this.__lightness;\n  }\n  /**\n   * Color intensity from 0 to 1\n   */\n  get _intensity() {\n    if (this.__intensity === -1) {\n      this.updateHSL();\n    }\n    return this.__intensity;\n  }\n}\nclass LeafGroup {\n  /**\n   * Store colors or groups and _count similiar groups in the image.\n   */\n  constructor() {\n    this._count = 0;\n    this._children = {};\n  }\n  /**\n   * Add color to the group.\n   *\n   * @param _hex Hexadecimal value of the color\n   * @param _red Red chanel amount of the color\n   * @param _green Green chanel amount of the color\n   * @param _blue Blue chanel amount of the color\n   * @returns The color\n   */\n  addColor(_hex, _red, _green, _blue) {\n    this._count++;\n    if (this._children[_hex]) {\n      this._children[_hex]._count++;\n    } else {\n      this._children[_hex] = new Color(_red, _green, _blue, _hex);\n    }\n    return this._children[_hex];\n  }\n  /**\n   * Get list of groups of list of colors.\n   *\n   * @returns List of colors\n   */\n  getList() {\n    return Object.keys(this._children).map(\n      (key) => this._children[key]\n    );\n  }\n  /**\n   * Representative color of leaf.\n   *\n   * @returns Main color of the leaf\n   */\n  createMainColor() {\n    const list = this.getList();\n    const biggest = list.reduce((a, b) => a._count >= b._count ? a : b);\n    const main = biggest.clone();\n    main._count = this._count;\n    return main;\n  }\n}\nclass RootGroup {\n  /**\n   * Store colors or groups and _count similiar groups in the image.\n   */\n  constructor() {\n    this._count = 0;\n    this._children = {};\n  }\n  /**\n   * Get list of groups of list of colors.\n   */\n  getList() {\n    return Object.keys(this._children).map(\n      (key) => this._children[key]\n    );\n  }\n  addColor(r, g, b) {\n    const full = r << 16 | g << 8 | b;\n    const loss = (r >> 4 & 15) << 8 | (g >> 4 & 15) << 4 | b >> 4 & 15;\n    this._count++;\n    return this.getLeafGroup(loss).addColor(full, r, g, b);\n  }\n  /**\n   * Add a key for a color, this key is a simplification to find neighboring colors.\n   * Neighboring colors has same key.\n   */\n  getLeafGroup(key) {\n    if (!this._children[key]) {\n      this._children[key] = new LeafGroup();\n    }\n    return this._children[key];\n  }\n  /**\n   * List of colors sorted by importance (neighboring hare calculated by distance and removed).\n   * Importance is calculated with the saturation and _count of neighboring colors.\n   */\n  getColors(_distance) {\n    const list = this.getList().map((child) => child.createMainColor());\n    list.sort((a, b) => b._count - a._count);\n    const newList = [];\n    while (list.length) {\n      const current = list.shift();\n      list.filter((color) => Color.distance(current, color) < _distance).forEach((near) => {\n        current._count += near._count;\n        const i = list.findIndex((color) => color === near);\n        list.splice(i, 1);\n      });\n      newList.push(current);\n    }\n    return newList;\n  }\n}\nconst extractor = ({\n  data,\n  width,\n  height\n}, _pixels, _distance, _colorValidator) => {\n  const colorGroup = new RootGroup();\n  const reducer = width && height ? Math.floor(width * height / _pixels) || 1 : 1;\n  let ignoredColorsCount = 0;\n  for (let i = 0; i < data.length; i += 4 * reducer) {\n    const r = data[i];\n    const g = data[i + 1];\n    const b = data[i + 2];\n    const a = data[i + 3];\n    if (_colorValidator(r, g, b, a)) {\n      colorGroup.addColor(r, g, b);\n    } else {\n      ignoredColorsCount++;\n    }\n  }\n  return {\n    colors: colorGroup.getColors(_distance),\n    count: colorGroup._count + ignoredColorsCount\n  };\n};\nconst distance = (a, b) => Math.abs(a - b);\nconst hueDistance = (a, b) => Math.min(distance(a, b), distance((a + 0.5) % 1, (b + 0.5) % 1));\nclass AverageGroup {\n  constructor() {\n    this.colors = [];\n    this._average = null;\n  }\n  addColor(color) {\n    this.colors.push(color);\n    this._average = null;\n  }\n  isSamePalette(color, hue, saturation, lightness) {\n    for (const currentColor of this.colors) {\n      const isSame = hueDistance(currentColor._hue, color._hue) < hue && distance(currentColor._saturation, color._saturation) < saturation && distance(currentColor._lightness, color._lightness) < lightness;\n      if (!isSame) {\n        return false;\n      }\n    }\n    return true;\n  }\n  get average() {\n    if (!this._average) {\n      const { r, g, b } = this.colors.reduce(\n        (total2, color) => {\n          total2.r += color._red;\n          total2.g += color._green;\n          total2.b += color._blue;\n          return total2;\n        },\n        { r: 0, g: 0, b: 0 }\n      );\n      const total = this.colors.reduce(\n        (_count, color) => _count + color._count,\n        0\n      );\n      this._average = new Color(\n        Math.round(r / this.colors.length),\n        Math.round(g / this.colors.length),\n        Math.round(b / this.colors.length)\n      );\n      this._average._count = total;\n    }\n    return this._average;\n  }\n}\nclass AverageManager {\n  constructor(hue, saturation, lightness) {\n    this._groups = [];\n    this._hue = hue;\n    this._saturation = saturation;\n    this._lightness = lightness;\n  }\n  addColor(color) {\n    const samePalette = this._groups.find(\n      (averageGroup) => averageGroup.isSamePalette(\n        color,\n        this._hue,\n        this._saturation,\n        this._lightness\n      )\n    );\n    if (samePalette) {\n      samePalette.addColor(color);\n    } else {\n      const averageGroup = new AverageGroup();\n      averageGroup.addColor(color);\n      this._groups.push(averageGroup);\n    }\n  }\n  getGroups() {\n    return this._groups.map((averageGroup) => averageGroup.average);\n  }\n}\nconst sortColors = (list, _pixels, _hueDistance, _saturationDistance, _lightnessDistance) => {\n  const averageManager = new AverageManager(\n    _hueDistance,\n    _saturationDistance,\n    _lightnessDistance\n  );\n  list.forEach((color) => averageManager.addColor(color));\n  const sorted = averageManager.getGroups();\n  sorted.sort((a, b) => {\n    const bPower = (b._intensity + 0.1) * (0.9 - b._count / _pixels);\n    const aPower = (a._intensity + 0.1) * (0.9 - a._count / _pixels);\n    return bPower - aPower;\n  });\n  return sorted;\n};\nconst createFinalColor = (color, pixels) => {\n  return {\n    hex: `#${\"0\".repeat(\n      6 - color._hex.toString(16).length\n    )}${color._hex.toString(16)}`,\n    red: color._red,\n    green: color._green,\n    blue: color._blue,\n    area: color._count / pixels,\n    hue: color._hue,\n    saturation: color._saturation,\n    lightness: color._lightness,\n    intensity: color._intensity\n  };\n};\nconst checkIsBrowser = () => typeof window !== \"undefined\" && typeof window.document !== \"undefined\";\nconst checkIsWorker = () => typeof self === \"object\" && self.constructor && self.constructor.name === \"DedicatedWorkerGlobalScope\";\nconst checkIsNode = () => typeof window === \"undefined\" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\ntypeof process !== \"undefined\" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nprocess.versions != null && // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nprocess.versions.node != null;\nconst sortFinalColors = (_colors, _pixels, _hueDistance, _saturationDistance, _lightnessDistance) => {\n  const list = sortColors(\n    _colors,\n    _pixels,\n    _hueDistance,\n    _saturationDistance,\n    _lightnessDistance\n  );\n  return list.map((color) => createFinalColor(color, _pixels));\n};\nconst extractImageData = (_image, _pixels) => {\n  const currentPixels = _image.width * _image.height;\n  const width = currentPixels < _pixels ? _image.width : Math.round(_image.width * Math.sqrt(_pixels / currentPixels));\n  const height = currentPixels < _pixels ? _image.height : Math.round(_image.height * Math.sqrt(_pixels / currentPixels));\n  const canvas = ((width2, height2) => {\n    if (checkIsWorker()) {\n      return new OffscreenCanvas(width2, height2);\n    }\n    const canvas2 = document.createElement(\"canvas\");\n    canvas2.width = width2;\n    canvas2.height = height2;\n    return canvas2;\n  })(width, height);\n  const context = canvas.getContext(\"2d\");\n  context.drawImage(\n    _image,\n    0,\n    0,\n    _image.width,\n    _image.height,\n    0,\n    0,\n    width,\n    height\n  );\n  return context.getImageData(0, 0, width, height);\n};\nconst extractColorsFromImageData = (imageData, options = {}) => {\n  if (true) {\n    testInputs(options);\n  }\n  const [\n    _pixels,\n    _distance,\n    _colorValidator,\n    _hueDistance,\n    _saturationDistance,\n    _lightnessDistance\n  ] = cleanInputs(options);\n  const { colors, count } = extractor(\n    imageData,\n    _pixels,\n    _distance,\n    _colorValidator\n  );\n  return sortFinalColors(\n    colors,\n    count,\n    _hueDistance,\n    _saturationDistance,\n    _lightnessDistance\n  );\n};\nconst extractColorsFromImage = async (image, options = {}) => {\n  if (checkIsNode()) {\n    if (true) {\n      throw new Error(\n        \"Use extractColors instead extractColorsFromImage for Node.js\"\n      );\n    }\n    return [];\n  }\n  if (true) {\n    testInputs(options);\n  }\n  const [\n    _pixels,\n    _distance,\n    _colorValidator,\n    _hueDistance,\n    _saturationDistance,\n    _lightnessDistance,\n    _crossOrigin\n  ] = cleanInputs(options);\n  image.crossOrigin = _crossOrigin;\n  return new Promise((resolve) => {\n    const extract = (image2) => {\n      const imageData = extractImageData(image2, _pixels);\n      const { colors, count } = extractor(\n        imageData,\n        _pixels,\n        _distance,\n        _colorValidator\n      );\n      resolve(\n        sortFinalColors(\n          colors,\n          count,\n          _hueDistance,\n          _saturationDistance,\n          _lightnessDistance\n        )\n      );\n    };\n    if (image.complete) {\n      extract(image);\n    } else {\n      const imageLoaded = () => {\n        image.removeEventListener(\"load\", imageLoaded);\n        extract(image);\n      };\n      image.addEventListener(\"load\", imageLoaded);\n    }\n  });\n};\nconst extractColorsFromImageBitmap = async (image, options = {}) => {\n  if (checkIsNode()) {\n    if (true) {\n      throw new Error(\n        \"Use extractColors instead extractColorsFromImageBitmap for Node.js\"\n      );\n    }\n    return [];\n  }\n  if (true) {\n    testInputs(options);\n  }\n  const [\n    _pixels,\n    _distance,\n    _colorValidator,\n    _hueDistance,\n    _saturationDistance,\n    _lightnessDistance\n  ] = cleanInputs(options);\n  const imageData = extractImageData(image, _pixels);\n  const { colors, count } = extractor(\n    imageData,\n    _pixels,\n    _distance,\n    _colorValidator\n  );\n  return sortFinalColors(\n    colors,\n    count,\n    _hueDistance,\n    _saturationDistance,\n    _lightnessDistance\n  );\n};\nconst extractColorsFromSrc = async (src, options = {}) => {\n  if (checkIsNode()) {\n    if (true) {\n      throw new Error(\"Can not use extractColorsFromSrc for Node.js\");\n    }\n    return [];\n  }\n  if (true) {\n    testInputs(options);\n  }\n  if (checkIsWorker()) {\n    const inputs = cleanInputs(options);\n    const response = await fetch(src, { mode: inputs[7] });\n    const blob = await response.blob();\n    const bitmap = await createImageBitmap(blob);\n    const colors = await extractColorsFromImageBitmap(bitmap, options);\n    bitmap.close();\n    return colors;\n  }\n  const image = new Image();\n  image.src = src;\n  return extractColorsFromImage(image, options);\n};\nconst extractColors = (picture, options) => {\n  if (checkIsBrowser()) {\n    if (true) {\n      if (options == null ? void 0 : options.requestMode) {\n        console.warn(\n          \"options.requestMode not supported in Browser, use options.crossOrigin instead\"\n        );\n      }\n    }\n    if (picture instanceof Image) {\n      return extractColorsFromImage(picture, options);\n    }\n    if (picture instanceof ImageData || picture instanceof Object && picture.data) {\n      return new Promise((resolve) => {\n        resolve(extractColorsFromImageData(picture, options));\n      });\n    }\n    if (typeof picture === \"string\") {\n      return extractColorsFromSrc(picture, options);\n    }\n  }\n  if (checkIsWorker()) {\n    if (true) {\n      if (options == null ? void 0 : options.crossOrigin) {\n        console.warn(\n          \"options.crossOrigin not supported in Web Worker, use options.requestMode instead\"\n        );\n      }\n    }\n    if (picture instanceof ImageData || picture instanceof Object && picture.data) {\n      return new Promise((resolve) => {\n        resolve(\n          extractColorsFromImageData(\n            picture,\n            options\n          )\n        );\n      });\n    }\n    if (typeof picture === \"string\") {\n      return extractColorsFromSrc(picture, options);\n    }\n    if (picture.src) {\n      if (true) {\n        console.warn(\n          \"HTMLImageElement not enable on worker, a fallback is used to extract src from your HTMLImageElement, please send 'src' instead HTMLImageElement\"\n        );\n      }\n      return extractColorsFromSrc(picture.src, options);\n    }\n  }\n  if (checkIsNode()) {\n    if (true) {\n      if (picture instanceof String) {\n        throw new Error(\n          \"Send imageData to extractColors (Image src or HTMLImageElement not supported in Nodejs)\"\n        );\n      }\n      if (!picture.data) {\n        throw new Error(\"Send imageData to extractColors\");\n      }\n      if (options == null ? void 0 : options.crossOrigin) {\n        console.warn(\"options.crossOrigin not supported in Node.js\");\n      }\n    }\n    return new Promise((resolve) => {\n      resolve(\n        extractColorsFromImageData(picture, options)\n      );\n    });\n  }\n  throw new Error(`Can not analyse picture`);\n};\n\n//# sourceMappingURL=extract-colors.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXh0cmFjdC1jb2xvcnMvbGliL2V4dHJhY3QtY29sb3JzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUk7QUFDTjtBQUNBO0FBQ0EseUJBQXlCLE9BQU8seUJBQXlCLElBQUk7QUFDN0Q7QUFDQTtBQUNBLHNCQUFzQixPQUFPLHVCQUF1QixLQUFLLFFBQVEsSUFBSTtBQUNyRTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU8sdUJBQXVCLEtBQUssUUFBUSxJQUFJO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTyx5QkFBeUIsSUFBSTtBQUM3RDtBQUNBO0FBQ0Esc0JBQXNCLE9BQU8sdUJBQXVCLEtBQUssUUFBUSxJQUFJO0FBQ3JFO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTyx1QkFBdUIsS0FBSyxRQUFRLElBQUk7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIseUJBQXlCLE9BQU8scUJBQXFCLElBQUk7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPLDRCQUE0QixvQkFBb0IsRUFBRSxnQkFBZ0IsU0FBUyxJQUFJO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxJQUFxQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFPRTtBQUNGIiwic291cmNlcyI6WyJEOlxcV29ya1xcY29kaW5nLXByYWN0aWNlXFxQcm9qZWN0IFByYWN0aWNlXFxlbnJlY28tY2hhcnRcXG5vZGVfbW9kdWxlc1xcZXh0cmFjdC1jb2xvcnNcXGxpYlxcZXh0cmFjdC1jb2xvcnMubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEVYVFJBQ1RPUl9QSVhFTFNfREVGQVVMVCA9IDY0ZTM7XG5jb25zdCBFWFRSQUNUT1JfRElTVEFOQ0VfREVGQVVMVCA9IDAuMjI7XG5jb25zdCBBVkVSQUdFX0hVRV9ERUZBVUxUID0gMSAvIDEyO1xuY29uc3QgQVZFUkFHRV9TQVRVUkFUSU9OX0RFRkFVTFQgPSAxIC8gNTtcbmNvbnN0IEFWRVJBR0VfTElHSFRORVNTX0RFRkFVTFQgPSAxIC8gNTtcbmZ1bmN0aW9uIHRlc3RJbnB1dHMoe1xuICBwaXhlbHMgPSBFWFRSQUNUT1JfUElYRUxTX0RFRkFVTFQsXG4gIGRpc3RhbmNlOiBkaXN0YW5jZTIgPSBFWFRSQUNUT1JfRElTVEFOQ0VfREVGQVVMVCxcbiAgY29sb3JWYWxpZGF0b3IgPSAoX3JlZCwgX2dyZWVuLCBfYmx1ZSwgX2FscGhhKSA9PiAoX2FscGhhID8/IDI1NSkgPiAyNTAsXG4gIGh1ZURpc3RhbmNlOiBodWVEaXN0YW5jZTIgPSBBVkVSQUdFX0hVRV9ERUZBVUxULFxuICBzYXR1cmF0aW9uRGlzdGFuY2UgPSBBVkVSQUdFX0xJR0hUTkVTU19ERUZBVUxULFxuICBsaWdodG5lc3NEaXN0YW5jZSA9IEFWRVJBR0VfU0FUVVJBVElPTl9ERUZBVUxULFxuICBjcm9zc09yaWdpbiA9IFwiXCIsXG4gIHJlcXVlc3RNb2RlID0gXCJjb3JzXCJcbn0gPSB7fSkge1xuICBjb25zdCB0ZXN0VWludCA9IChsYWJlbCwgdmFsLCBtaW4gPSAwLCBtYXggPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikgPT4ge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcih2YWwpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bGFiZWx9IGlzIG5vdCBhIHZhbGlkIG51bWJlciAoJHt2YWx9KWApO1xuICAgIH1cbiAgICBpZiAodmFsIDwgbWluKSB7XG4gICAgICBjb25zb2xlLndhcm4oYCR7bGFiZWx9IGNhbiBub3QgYmUgbGVzcyB0aGFuICR7bWlufSAoaXQncyAke3ZhbH0pYCk7XG4gICAgfVxuICAgIGlmICh2YWwgPiBtYXgpIHtcbiAgICAgIGNvbnNvbGUud2FybihgJHtsYWJlbH0gY2FuIG5vdCBiZSBtb3JlIHRoYW4gJHttYXh9IChpdCdzICR7dmFsfSlgKTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbCwgbWluKSwgbWF4KTtcbiAgfTtcbiAgY29uc3QgdGVzdE51bWJlciA9IChsYWJlbCwgdmFsLCBtaW4gPSAwLCBtYXggPSBOdW1iZXIuTUFYX1ZBTFVFKSA9PiB7XG4gICAgaWYgKE51bWJlcih2YWwpICE9PSB2YWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtsYWJlbH0gaXMgbm90IGEgdmFsaWQgbnVtYmVyICgke3ZhbH0pYCk7XG4gICAgfVxuICAgIGlmICh2YWwgPCBtaW4pIHtcbiAgICAgIGNvbnNvbGUud2FybihgJHtsYWJlbH0gY2FuIG5vdCBiZSBsZXNzIHRoYW4gJHttaW59IChpdCdzICR7dmFsfSlgKTtcbiAgICB9XG4gICAgaWYgKHZhbCA+IG1heCkge1xuICAgICAgY29uc29sZS53YXJuKGAke2xhYmVsfSBjYW4gbm90IGJlIG1vcmUgdGhhbiAke21heH0gKGl0J3MgJHt2YWx9KWApO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodmFsLCBtaW4pLCBtYXgpO1xuICB9O1xuICBjb25zdCB0ZXN0RnVuY3Rpb24gPSAobGFiZWwsIHZhbCkgPT4ge1xuICAgIGlmICghdmFsIHx8IHt9LnRvU3RyaW5nLmNhbGwodmFsKSAhPT0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bGFiZWx9IGlzIG5vdCBhIGZ1bmN0aW9uICgke3ZhbH0pYCk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG4gIH07XG4gIGNvbnN0IHRlc3RWYWx1ZUluTGlzdCA9IChsYWJlbCwgdmFsLCBsaXN0KSA9PiB7XG4gICAgaWYgKGxpc3QuaW5kZXhPZih2YWwpIDwgMCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgJHtsYWJlbH0gY2FuIGJlIG9uZSBvZiB0aGlzIHZhbHVlcyAke2xpc3QubWFwKCh2KSA9PiBgXCIke3Z9XCJgKS5qb2luKFwiLCBcIil9IChpdCdzIFwiJHt2YWx9XCIpYFxuICAgICAgKTtcbiAgICB9XG4gIH07XG4gIHRlc3RVaW50KFwicGl4ZWxzXCIsIHBpeGVscyB8fCAwLCAxKTtcbiAgdGVzdE51bWJlcihcImRpc3RhbmNlXCIsIGRpc3RhbmNlMiwgMCwgMSk7XG4gIHRlc3RGdW5jdGlvbihcImNvbG9yVmFsaWRhdG9yXCIsIGNvbG9yVmFsaWRhdG9yKTtcbiAgdGVzdE51bWJlcihcImh1ZURpc3RhbmNlXCIsIGh1ZURpc3RhbmNlMiwgMCwgMSk7XG4gIHRlc3ROdW1iZXIoXCJzYXR1cmF0aW9uRGlzdGFuY2VcIiwgc2F0dXJhdGlvbkRpc3RhbmNlLCAwLCAxKTtcbiAgdGVzdE51bWJlcihcImxpZ2h0bmVzc0Rpc3RhbmNlXCIsIGxpZ2h0bmVzc0Rpc3RhbmNlLCAwLCAxKTtcbiAgdGVzdFZhbHVlSW5MaXN0KFwiY3Jvc3NPcmlnaW5cIiwgY3Jvc3NPcmlnaW4sIFtcbiAgICBcIlwiLFxuICAgIFwiYW5vbnltb3VzXCIsXG4gICAgXCJ1c2UtY3JlZGVudGlhbHNcIlxuICBdKTtcbiAgdGVzdFZhbHVlSW5MaXN0KFwicmVxdWVzdE1vZGVcIiwgcmVxdWVzdE1vZGUsIFtcbiAgICBcImNvcnNcIixcbiAgICBcIm5hdmlnYXRlXCIsXG4gICAgXCJuby1jb3JzXCIsXG4gICAgXCJzYW1lLW9yaWdpblwiXG4gIF0pO1xufVxuY29uc3QgY2xlYW5JbnB1dHMgPSAoe1xuICBwaXhlbHMgPSBFWFRSQUNUT1JfUElYRUxTX0RFRkFVTFQsXG4gIGRpc3RhbmNlOiBkaXN0YW5jZTIgPSBFWFRSQUNUT1JfRElTVEFOQ0VfREVGQVVMVCxcbiAgY29sb3JWYWxpZGF0b3IgPSAoX3JlZCwgX2dyZWVuLCBfYmx1ZSwgX2FscGhhKSA9PiAoX2FscGhhID8/IDI1NSkgPiAyNTAsXG4gIGh1ZURpc3RhbmNlOiBodWVEaXN0YW5jZTIgPSBBVkVSQUdFX0hVRV9ERUZBVUxULFxuICBzYXR1cmF0aW9uRGlzdGFuY2UgPSBBVkVSQUdFX0xJR0hUTkVTU19ERUZBVUxULFxuICBsaWdodG5lc3NEaXN0YW5jZSA9IEFWRVJBR0VfU0FUVVJBVElPTl9ERUZBVUxULFxuICBjcm9zc09yaWdpbiA9IFwiXCIsXG4gIHJlcXVlc3RNb2RlID0gXCJjb3JzXCJcbn0gPSB7fSkgPT4ge1xuICByZXR1cm4gW1xuICAgIE1hdGgubWF4KHBpeGVscywgMSksXG4gICAgTWF0aC5taW4oTWF0aC5tYXgoZGlzdGFuY2UyLCAwKSwgMSksXG4gICAgY29sb3JWYWxpZGF0b3IsXG4gICAgTWF0aC5taW4oTWF0aC5tYXgoaHVlRGlzdGFuY2UyLCAwKSwgMSksXG4gICAgTWF0aC5taW4oTWF0aC5tYXgoc2F0dXJhdGlvbkRpc3RhbmNlLCAwKSwgMSksXG4gICAgTWF0aC5taW4oTWF0aC5tYXgobGlnaHRuZXNzRGlzdGFuY2UsIDApLCAxKSxcbiAgICBjcm9zc09yaWdpbixcbiAgICByZXF1ZXN0TW9kZVxuICBdO1xufTtcbmNsYXNzIENvbG9yIHtcbiAgLyoqXG4gICAqIFNldCByZWQsIGdyZWVuIGFuZCBibHVlIGNvbG9ycyB0byBjcmVhdGUgdGhlIENvbG9yIG9iamVjdC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlZCwgZ3JlZW4sIGJsdWUsIGhleCA9IHJlZCA8PCAxNiB8IGdyZWVuIDw8IDggfCBibHVlKSB7XG4gICAgdGhpcy5fY291bnQgPSAxO1xuICAgIHRoaXMuX19zYXR1cmF0aW9uID0gLTE7XG4gICAgdGhpcy5fX2h1ZSA9IC0xO1xuICAgIHRoaXMuX19saWdodG5lc3MgPSAtMTtcbiAgICB0aGlzLl9faW50ZW5zaXR5ID0gLTE7XG4gICAgdGhpcy5fcmVkID0gcmVkO1xuICAgIHRoaXMuX2dyZWVuID0gZ3JlZW47XG4gICAgdGhpcy5fYmx1ZSA9IGJsdWU7XG4gICAgdGhpcy5faGV4ID0gaGV4O1xuICB9XG4gIC8qKlxuICAgKiBEaXN0YW5jZSBiZXR3ZWVuIHR3byBjb2xvcnMuXG4gICAqIC0gTWluaW11bSBpcyAwIChiZXR3ZWVuIHR3byBzYW1lIGNvbG9ycylcbiAgICogLSBNYXhpbXVtIGlzIDEgKGZvciBleGFtcGxlIGJldHdlZW4gYmxhY2sgYW5kIHdoaXRlKVxuICAgKi9cbiAgc3RhdGljIGRpc3RhbmNlKGNvbG9yQSwgY29sb3JCKSB7XG4gICAgcmV0dXJuIChNYXRoLmFicyhjb2xvckIuX3JlZCAtIGNvbG9yQS5fcmVkKSArIE1hdGguYWJzKGNvbG9yQi5fZ3JlZW4gLSBjb2xvckEuX2dyZWVuKSArIE1hdGguYWJzKGNvbG9yQi5fYmx1ZSAtIGNvbG9yQS5fYmx1ZSkpIC8gKDMgKiAyNTUpO1xuICB9XG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKHRoaXMuX3JlZCwgdGhpcy5fZ3JlZW4sIHRoaXMuX2JsdWUsIHRoaXMuX2hleCk7XG4gICAgY29sb3IuX2NvdW50ID0gdGhpcy5fY291bnQ7XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG4gIHVwZGF0ZUhTTCgpIHtcbiAgICBjb25zdCByZWQgPSB0aGlzLl9yZWQgLyAyNTU7XG4gICAgY29uc3QgZ3JlZW4gPSB0aGlzLl9ncmVlbiAvIDI1NTtcbiAgICBjb25zdCBibHVlID0gdGhpcy5fYmx1ZSAvIDI1NTtcbiAgICBjb25zdCBtYXggPSBNYXRoLm1heChyZWQsIGdyZWVuLCBibHVlKTtcbiAgICBjb25zdCBtaW4gPSBNYXRoLm1pbihyZWQsIGdyZWVuLCBibHVlKTtcbiAgICB0aGlzLl9fbGlnaHRuZXNzID0gKG1heCArIG1pbikgLyAyO1xuICAgIGlmIChtYXggPT09IG1pbikge1xuICAgICAgdGhpcy5fX2h1ZSA9IDA7XG4gICAgICB0aGlzLl9fc2F0dXJhdGlvbiA9IDA7XG4gICAgICB0aGlzLl9faW50ZW5zaXR5ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZGlzdGFuY2UyID0gbWF4IC0gbWluO1xuICAgICAgdGhpcy5fX3NhdHVyYXRpb24gPSB0aGlzLl9fbGlnaHRuZXNzID4gMC41ID8gZGlzdGFuY2UyIC8gKDIgLSBtYXggLSBtaW4pIDogZGlzdGFuY2UyIC8gKG1heCArIG1pbik7XG4gICAgICB0aGlzLl9faW50ZW5zaXR5ID0gdGhpcy5fX3NhdHVyYXRpb24gKiAoKDAuNSAtIE1hdGguYWJzKDAuNSAtIHRoaXMuX19saWdodG5lc3MpKSAqIDIpO1xuICAgICAgc3dpdGNoIChtYXgpIHtcbiAgICAgICAgY2FzZSByZWQ6XG4gICAgICAgICAgdGhpcy5fX2h1ZSA9ICgoZ3JlZW4gLSBibHVlKSAvIGRpc3RhbmNlMiArIChncmVlbiA8IGJsdWUgPyA2IDogMCkpIC8gNjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBncmVlbjpcbiAgICAgICAgICB0aGlzLl9faHVlID0gKChibHVlIC0gcmVkKSAvIGRpc3RhbmNlMiArIDIpIC8gNjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBibHVlOlxuICAgICAgICAgIHRoaXMuX19odWUgPSAoKHJlZCAtIGdyZWVuKSAvIGRpc3RhbmNlMiArIDQpIC8gNjtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEh1ZSBmcm9tIDAgdG8gMVxuICAgKi9cbiAgZ2V0IF9odWUoKSB7XG4gICAgaWYgKHRoaXMuX19odWUgPT09IC0xKSB7XG4gICAgICB0aGlzLnVwZGF0ZUhTTCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fX2h1ZTtcbiAgfVxuICAvKipcbiAgICogU2F0dXJhdGlvbiBmcm9tIDAgdG8gMVxuICAgKi9cbiAgZ2V0IF9zYXR1cmF0aW9uKCkge1xuICAgIGlmICh0aGlzLl9fc2F0dXJhdGlvbiA9PT0gLTEpIHtcbiAgICAgIHRoaXMudXBkYXRlSFNMKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9fc2F0dXJhdGlvbjtcbiAgfVxuICAvKipcbiAgICogTGlnaHRuZXNzIGZyb20gMCB0byAxXG4gICAqL1xuICBnZXQgX2xpZ2h0bmVzcygpIHtcbiAgICBpZiAodGhpcy5fX2xpZ2h0bmVzcyA9PT0gLTEpIHtcbiAgICAgIHRoaXMudXBkYXRlSFNMKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9fbGlnaHRuZXNzO1xuICB9XG4gIC8qKlxuICAgKiBDb2xvciBpbnRlbnNpdHkgZnJvbSAwIHRvIDFcbiAgICovXG4gIGdldCBfaW50ZW5zaXR5KCkge1xuICAgIGlmICh0aGlzLl9faW50ZW5zaXR5ID09PSAtMSkge1xuICAgICAgdGhpcy51cGRhdGVIU0woKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX19pbnRlbnNpdHk7XG4gIH1cbn1cbmNsYXNzIExlYWZHcm91cCB7XG4gIC8qKlxuICAgKiBTdG9yZSBjb2xvcnMgb3IgZ3JvdXBzIGFuZCBfY291bnQgc2ltaWxpYXIgZ3JvdXBzIGluIHRoZSBpbWFnZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2NvdW50ID0gMDtcbiAgICB0aGlzLl9jaGlsZHJlbiA9IHt9O1xuICB9XG4gIC8qKlxuICAgKiBBZGQgY29sb3IgdG8gdGhlIGdyb3VwLlxuICAgKlxuICAgKiBAcGFyYW0gX2hleCBIZXhhZGVjaW1hbCB2YWx1ZSBvZiB0aGUgY29sb3JcbiAgICogQHBhcmFtIF9yZWQgUmVkIGNoYW5lbCBhbW91bnQgb2YgdGhlIGNvbG9yXG4gICAqIEBwYXJhbSBfZ3JlZW4gR3JlZW4gY2hhbmVsIGFtb3VudCBvZiB0aGUgY29sb3JcbiAgICogQHBhcmFtIF9ibHVlIEJsdWUgY2hhbmVsIGFtb3VudCBvZiB0aGUgY29sb3JcbiAgICogQHJldHVybnMgVGhlIGNvbG9yXG4gICAqL1xuICBhZGRDb2xvcihfaGV4LCBfcmVkLCBfZ3JlZW4sIF9ibHVlKSB7XG4gICAgdGhpcy5fY291bnQrKztcbiAgICBpZiAodGhpcy5fY2hpbGRyZW5bX2hleF0pIHtcbiAgICAgIHRoaXMuX2NoaWxkcmVuW19oZXhdLl9jb3VudCsrO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9jaGlsZHJlbltfaGV4XSA9IG5ldyBDb2xvcihfcmVkLCBfZ3JlZW4sIF9ibHVlLCBfaGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuW19oZXhdO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgbGlzdCBvZiBncm91cHMgb2YgbGlzdCBvZiBjb2xvcnMuXG4gICAqXG4gICAqIEByZXR1cm5zIExpc3Qgb2YgY29sb3JzXG4gICAqL1xuICBnZXRMaXN0KCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9jaGlsZHJlbikubWFwKFxuICAgICAgKGtleSkgPT4gdGhpcy5fY2hpbGRyZW5ba2V5XVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFJlcHJlc2VudGF0aXZlIGNvbG9yIG9mIGxlYWYuXG4gICAqXG4gICAqIEByZXR1cm5zIE1haW4gY29sb3Igb2YgdGhlIGxlYWZcbiAgICovXG4gIGNyZWF0ZU1haW5Db2xvcigpIHtcbiAgICBjb25zdCBsaXN0ID0gdGhpcy5nZXRMaXN0KCk7XG4gICAgY29uc3QgYmlnZ2VzdCA9IGxpc3QucmVkdWNlKChhLCBiKSA9PiBhLl9jb3VudCA+PSBiLl9jb3VudCA/IGEgOiBiKTtcbiAgICBjb25zdCBtYWluID0gYmlnZ2VzdC5jbG9uZSgpO1xuICAgIG1haW4uX2NvdW50ID0gdGhpcy5fY291bnQ7XG4gICAgcmV0dXJuIG1haW47XG4gIH1cbn1cbmNsYXNzIFJvb3RHcm91cCB7XG4gIC8qKlxuICAgKiBTdG9yZSBjb2xvcnMgb3IgZ3JvdXBzIGFuZCBfY291bnQgc2ltaWxpYXIgZ3JvdXBzIGluIHRoZSBpbWFnZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2NvdW50ID0gMDtcbiAgICB0aGlzLl9jaGlsZHJlbiA9IHt9O1xuICB9XG4gIC8qKlxuICAgKiBHZXQgbGlzdCBvZiBncm91cHMgb2YgbGlzdCBvZiBjb2xvcnMuXG4gICAqL1xuICBnZXRMaXN0KCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9jaGlsZHJlbikubWFwKFxuICAgICAgKGtleSkgPT4gdGhpcy5fY2hpbGRyZW5ba2V5XVxuICAgICk7XG4gIH1cbiAgYWRkQ29sb3IociwgZywgYikge1xuICAgIGNvbnN0IGZ1bGwgPSByIDw8IDE2IHwgZyA8PCA4IHwgYjtcbiAgICBjb25zdCBsb3NzID0gKHIgPj4gNCAmIDE1KSA8PCA4IHwgKGcgPj4gNCAmIDE1KSA8PCA0IHwgYiA+PiA0ICYgMTU7XG4gICAgdGhpcy5fY291bnQrKztcbiAgICByZXR1cm4gdGhpcy5nZXRMZWFmR3JvdXAobG9zcykuYWRkQ29sb3IoZnVsbCwgciwgZywgYik7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBhIGtleSBmb3IgYSBjb2xvciwgdGhpcyBrZXkgaXMgYSBzaW1wbGlmaWNhdGlvbiB0byBmaW5kIG5laWdoYm9yaW5nIGNvbG9ycy5cbiAgICogTmVpZ2hib3JpbmcgY29sb3JzIGhhcyBzYW1lIGtleS5cbiAgICovXG4gIGdldExlYWZHcm91cChrZXkpIHtcbiAgICBpZiAoIXRoaXMuX2NoaWxkcmVuW2tleV0pIHtcbiAgICAgIHRoaXMuX2NoaWxkcmVuW2tleV0gPSBuZXcgTGVhZkdyb3VwKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbltrZXldO1xuICB9XG4gIC8qKlxuICAgKiBMaXN0IG9mIGNvbG9ycyBzb3J0ZWQgYnkgaW1wb3J0YW5jZSAobmVpZ2hib3JpbmcgaGFyZSBjYWxjdWxhdGVkIGJ5IGRpc3RhbmNlIGFuZCByZW1vdmVkKS5cbiAgICogSW1wb3J0YW5jZSBpcyBjYWxjdWxhdGVkIHdpdGggdGhlIHNhdHVyYXRpb24gYW5kIF9jb3VudCBvZiBuZWlnaGJvcmluZyBjb2xvcnMuXG4gICAqL1xuICBnZXRDb2xvcnMoX2Rpc3RhbmNlKSB7XG4gICAgY29uc3QgbGlzdCA9IHRoaXMuZ2V0TGlzdCgpLm1hcCgoY2hpbGQpID0+IGNoaWxkLmNyZWF0ZU1haW5Db2xvcigpKTtcbiAgICBsaXN0LnNvcnQoKGEsIGIpID0+IGIuX2NvdW50IC0gYS5fY291bnQpO1xuICAgIGNvbnN0IG5ld0xpc3QgPSBbXTtcbiAgICB3aGlsZSAobGlzdC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSBsaXN0LnNoaWZ0KCk7XG4gICAgICBsaXN0LmZpbHRlcigoY29sb3IpID0+IENvbG9yLmRpc3RhbmNlKGN1cnJlbnQsIGNvbG9yKSA8IF9kaXN0YW5jZSkuZm9yRWFjaCgobmVhcikgPT4ge1xuICAgICAgICBjdXJyZW50Ll9jb3VudCArPSBuZWFyLl9jb3VudDtcbiAgICAgICAgY29uc3QgaSA9IGxpc3QuZmluZEluZGV4KChjb2xvcikgPT4gY29sb3IgPT09IG5lYXIpO1xuICAgICAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICAgIH0pO1xuICAgICAgbmV3TGlzdC5wdXNoKGN1cnJlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3TGlzdDtcbiAgfVxufVxuY29uc3QgZXh0cmFjdG9yID0gKHtcbiAgZGF0YSxcbiAgd2lkdGgsXG4gIGhlaWdodFxufSwgX3BpeGVscywgX2Rpc3RhbmNlLCBfY29sb3JWYWxpZGF0b3IpID0+IHtcbiAgY29uc3QgY29sb3JHcm91cCA9IG5ldyBSb290R3JvdXAoKTtcbiAgY29uc3QgcmVkdWNlciA9IHdpZHRoICYmIGhlaWdodCA/IE1hdGguZmxvb3Iod2lkdGggKiBoZWlnaHQgLyBfcGl4ZWxzKSB8fCAxIDogMTtcbiAgbGV0IGlnbm9yZWRDb2xvcnNDb3VudCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gNCAqIHJlZHVjZXIpIHtcbiAgICBjb25zdCByID0gZGF0YVtpXTtcbiAgICBjb25zdCBnID0gZGF0YVtpICsgMV07XG4gICAgY29uc3QgYiA9IGRhdGFbaSArIDJdO1xuICAgIGNvbnN0IGEgPSBkYXRhW2kgKyAzXTtcbiAgICBpZiAoX2NvbG9yVmFsaWRhdG9yKHIsIGcsIGIsIGEpKSB7XG4gICAgICBjb2xvckdyb3VwLmFkZENvbG9yKHIsIGcsIGIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZ25vcmVkQ29sb3JzQ291bnQrKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjb2xvcnM6IGNvbG9yR3JvdXAuZ2V0Q29sb3JzKF9kaXN0YW5jZSksXG4gICAgY291bnQ6IGNvbG9yR3JvdXAuX2NvdW50ICsgaWdub3JlZENvbG9yc0NvdW50XG4gIH07XG59O1xuY29uc3QgZGlzdGFuY2UgPSAoYSwgYikgPT4gTWF0aC5hYnMoYSAtIGIpO1xuY29uc3QgaHVlRGlzdGFuY2UgPSAoYSwgYikgPT4gTWF0aC5taW4oZGlzdGFuY2UoYSwgYiksIGRpc3RhbmNlKChhICsgMC41KSAlIDEsIChiICsgMC41KSAlIDEpKTtcbmNsYXNzIEF2ZXJhZ2VHcm91cCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY29sb3JzID0gW107XG4gICAgdGhpcy5fYXZlcmFnZSA9IG51bGw7XG4gIH1cbiAgYWRkQ29sb3IoY29sb3IpIHtcbiAgICB0aGlzLmNvbG9ycy5wdXNoKGNvbG9yKTtcbiAgICB0aGlzLl9hdmVyYWdlID0gbnVsbDtcbiAgfVxuICBpc1NhbWVQYWxldHRlKGNvbG9yLCBodWUsIHNhdHVyYXRpb24sIGxpZ2h0bmVzcykge1xuICAgIGZvciAoY29uc3QgY3VycmVudENvbG9yIG9mIHRoaXMuY29sb3JzKSB7XG4gICAgICBjb25zdCBpc1NhbWUgPSBodWVEaXN0YW5jZShjdXJyZW50Q29sb3IuX2h1ZSwgY29sb3IuX2h1ZSkgPCBodWUgJiYgZGlzdGFuY2UoY3VycmVudENvbG9yLl9zYXR1cmF0aW9uLCBjb2xvci5fc2F0dXJhdGlvbikgPCBzYXR1cmF0aW9uICYmIGRpc3RhbmNlKGN1cnJlbnRDb2xvci5fbGlnaHRuZXNzLCBjb2xvci5fbGlnaHRuZXNzKSA8IGxpZ2h0bmVzcztcbiAgICAgIGlmICghaXNTYW1lKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZ2V0IGF2ZXJhZ2UoKSB7XG4gICAgaWYgKCF0aGlzLl9hdmVyYWdlKSB7XG4gICAgICBjb25zdCB7IHIsIGcsIGIgfSA9IHRoaXMuY29sb3JzLnJlZHVjZShcbiAgICAgICAgKHRvdGFsMiwgY29sb3IpID0+IHtcbiAgICAgICAgICB0b3RhbDIuciArPSBjb2xvci5fcmVkO1xuICAgICAgICAgIHRvdGFsMi5nICs9IGNvbG9yLl9ncmVlbjtcbiAgICAgICAgICB0b3RhbDIuYiArPSBjb2xvci5fYmx1ZTtcbiAgICAgICAgICByZXR1cm4gdG90YWwyO1xuICAgICAgICB9LFxuICAgICAgICB7IHI6IDAsIGc6IDAsIGI6IDAgfVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHRvdGFsID0gdGhpcy5jb2xvcnMucmVkdWNlKFxuICAgICAgICAoX2NvdW50LCBjb2xvcikgPT4gX2NvdW50ICsgY29sb3IuX2NvdW50LFxuICAgICAgICAwXG4gICAgICApO1xuICAgICAgdGhpcy5fYXZlcmFnZSA9IG5ldyBDb2xvcihcbiAgICAgICAgTWF0aC5yb3VuZChyIC8gdGhpcy5jb2xvcnMubGVuZ3RoKSxcbiAgICAgICAgTWF0aC5yb3VuZChnIC8gdGhpcy5jb2xvcnMubGVuZ3RoKSxcbiAgICAgICAgTWF0aC5yb3VuZChiIC8gdGhpcy5jb2xvcnMubGVuZ3RoKVxuICAgICAgKTtcbiAgICAgIHRoaXMuX2F2ZXJhZ2UuX2NvdW50ID0gdG90YWw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9hdmVyYWdlO1xuICB9XG59XG5jbGFzcyBBdmVyYWdlTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGh1ZSwgc2F0dXJhdGlvbiwgbGlnaHRuZXNzKSB7XG4gICAgdGhpcy5fZ3JvdXBzID0gW107XG4gICAgdGhpcy5faHVlID0gaHVlO1xuICAgIHRoaXMuX3NhdHVyYXRpb24gPSBzYXR1cmF0aW9uO1xuICAgIHRoaXMuX2xpZ2h0bmVzcyA9IGxpZ2h0bmVzcztcbiAgfVxuICBhZGRDb2xvcihjb2xvcikge1xuICAgIGNvbnN0IHNhbWVQYWxldHRlID0gdGhpcy5fZ3JvdXBzLmZpbmQoXG4gICAgICAoYXZlcmFnZUdyb3VwKSA9PiBhdmVyYWdlR3JvdXAuaXNTYW1lUGFsZXR0ZShcbiAgICAgICAgY29sb3IsXG4gICAgICAgIHRoaXMuX2h1ZSxcbiAgICAgICAgdGhpcy5fc2F0dXJhdGlvbixcbiAgICAgICAgdGhpcy5fbGlnaHRuZXNzXG4gICAgICApXG4gICAgKTtcbiAgICBpZiAoc2FtZVBhbGV0dGUpIHtcbiAgICAgIHNhbWVQYWxldHRlLmFkZENvbG9yKGNvbG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYXZlcmFnZUdyb3VwID0gbmV3IEF2ZXJhZ2VHcm91cCgpO1xuICAgICAgYXZlcmFnZUdyb3VwLmFkZENvbG9yKGNvbG9yKTtcbiAgICAgIHRoaXMuX2dyb3Vwcy5wdXNoKGF2ZXJhZ2VHcm91cCk7XG4gICAgfVxuICB9XG4gIGdldEdyb3VwcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZ3JvdXBzLm1hcCgoYXZlcmFnZUdyb3VwKSA9PiBhdmVyYWdlR3JvdXAuYXZlcmFnZSk7XG4gIH1cbn1cbmNvbnN0IHNvcnRDb2xvcnMgPSAobGlzdCwgX3BpeGVscywgX2h1ZURpc3RhbmNlLCBfc2F0dXJhdGlvbkRpc3RhbmNlLCBfbGlnaHRuZXNzRGlzdGFuY2UpID0+IHtcbiAgY29uc3QgYXZlcmFnZU1hbmFnZXIgPSBuZXcgQXZlcmFnZU1hbmFnZXIoXG4gICAgX2h1ZURpc3RhbmNlLFxuICAgIF9zYXR1cmF0aW9uRGlzdGFuY2UsXG4gICAgX2xpZ2h0bmVzc0Rpc3RhbmNlXG4gICk7XG4gIGxpc3QuZm9yRWFjaCgoY29sb3IpID0+IGF2ZXJhZ2VNYW5hZ2VyLmFkZENvbG9yKGNvbG9yKSk7XG4gIGNvbnN0IHNvcnRlZCA9IGF2ZXJhZ2VNYW5hZ2VyLmdldEdyb3VwcygpO1xuICBzb3J0ZWQuc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IGJQb3dlciA9IChiLl9pbnRlbnNpdHkgKyAwLjEpICogKDAuOSAtIGIuX2NvdW50IC8gX3BpeGVscyk7XG4gICAgY29uc3QgYVBvd2VyID0gKGEuX2ludGVuc2l0eSArIDAuMSkgKiAoMC45IC0gYS5fY291bnQgLyBfcGl4ZWxzKTtcbiAgICByZXR1cm4gYlBvd2VyIC0gYVBvd2VyO1xuICB9KTtcbiAgcmV0dXJuIHNvcnRlZDtcbn07XG5jb25zdCBjcmVhdGVGaW5hbENvbG9yID0gKGNvbG9yLCBwaXhlbHMpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBoZXg6IGAjJHtcIjBcIi5yZXBlYXQoXG4gICAgICA2IC0gY29sb3IuX2hleC50b1N0cmluZygxNikubGVuZ3RoXG4gICAgKX0ke2NvbG9yLl9oZXgudG9TdHJpbmcoMTYpfWAsXG4gICAgcmVkOiBjb2xvci5fcmVkLFxuICAgIGdyZWVuOiBjb2xvci5fZ3JlZW4sXG4gICAgYmx1ZTogY29sb3IuX2JsdWUsXG4gICAgYXJlYTogY29sb3IuX2NvdW50IC8gcGl4ZWxzLFxuICAgIGh1ZTogY29sb3IuX2h1ZSxcbiAgICBzYXR1cmF0aW9uOiBjb2xvci5fc2F0dXJhdGlvbixcbiAgICBsaWdodG5lc3M6IGNvbG9yLl9saWdodG5lc3MsXG4gICAgaW50ZW5zaXR5OiBjb2xvci5faW50ZW5zaXR5XG4gIH07XG59O1xuY29uc3QgY2hlY2tJc0Jyb3dzZXIgPSAoKSA9PiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG5jb25zdCBjaGVja0lzV29ya2VyID0gKCkgPT4gdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgJiYgc2VsZi5jb25zdHJ1Y3RvciAmJiBzZWxmLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiRGVkaWNhdGVkV29ya2VyR2xvYmFsU2NvcGVcIjtcbmNvbnN0IGNoZWNrSXNOb2RlID0gKCkgPT4gdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiAmJiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4vLyBAdHMtaWdub3JlXG50eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4vLyBAdHMtaWdub3JlXG5wcm9jZXNzLnZlcnNpb25zICE9IG51bGwgJiYgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuLy8gQHRzLWlnbm9yZVxucHJvY2Vzcy52ZXJzaW9ucy5ub2RlICE9IG51bGw7XG5jb25zdCBzb3J0RmluYWxDb2xvcnMgPSAoX2NvbG9ycywgX3BpeGVscywgX2h1ZURpc3RhbmNlLCBfc2F0dXJhdGlvbkRpc3RhbmNlLCBfbGlnaHRuZXNzRGlzdGFuY2UpID0+IHtcbiAgY29uc3QgbGlzdCA9IHNvcnRDb2xvcnMoXG4gICAgX2NvbG9ycyxcbiAgICBfcGl4ZWxzLFxuICAgIF9odWVEaXN0YW5jZSxcbiAgICBfc2F0dXJhdGlvbkRpc3RhbmNlLFxuICAgIF9saWdodG5lc3NEaXN0YW5jZVxuICApO1xuICByZXR1cm4gbGlzdC5tYXAoKGNvbG9yKSA9PiBjcmVhdGVGaW5hbENvbG9yKGNvbG9yLCBfcGl4ZWxzKSk7XG59O1xuY29uc3QgZXh0cmFjdEltYWdlRGF0YSA9IChfaW1hZ2UsIF9waXhlbHMpID0+IHtcbiAgY29uc3QgY3VycmVudFBpeGVscyA9IF9pbWFnZS53aWR0aCAqIF9pbWFnZS5oZWlnaHQ7XG4gIGNvbnN0IHdpZHRoID0gY3VycmVudFBpeGVscyA8IF9waXhlbHMgPyBfaW1hZ2Uud2lkdGggOiBNYXRoLnJvdW5kKF9pbWFnZS53aWR0aCAqIE1hdGguc3FydChfcGl4ZWxzIC8gY3VycmVudFBpeGVscykpO1xuICBjb25zdCBoZWlnaHQgPSBjdXJyZW50UGl4ZWxzIDwgX3BpeGVscyA/IF9pbWFnZS5oZWlnaHQgOiBNYXRoLnJvdW5kKF9pbWFnZS5oZWlnaHQgKiBNYXRoLnNxcnQoX3BpeGVscyAvIGN1cnJlbnRQaXhlbHMpKTtcbiAgY29uc3QgY2FudmFzID0gKCh3aWR0aDIsIGhlaWdodDIpID0+IHtcbiAgICBpZiAoY2hlY2tJc1dvcmtlcigpKSB7XG4gICAgICByZXR1cm4gbmV3IE9mZnNjcmVlbkNhbnZhcyh3aWR0aDIsIGhlaWdodDIpO1xuICAgIH1cbiAgICBjb25zdCBjYW52YXMyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBjYW52YXMyLndpZHRoID0gd2lkdGgyO1xuICAgIGNhbnZhczIuaGVpZ2h0ID0gaGVpZ2h0MjtcbiAgICByZXR1cm4gY2FudmFzMjtcbiAgfSkod2lkdGgsIGhlaWdodCk7XG4gIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICBjb250ZXh0LmRyYXdJbWFnZShcbiAgICBfaW1hZ2UsXG4gICAgMCxcbiAgICAwLFxuICAgIF9pbWFnZS53aWR0aCxcbiAgICBfaW1hZ2UuaGVpZ2h0LFxuICAgIDAsXG4gICAgMCxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgKTtcbiAgcmV0dXJuIGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xufTtcbmNvbnN0IGV4dHJhY3RDb2xvcnNGcm9tSW1hZ2VEYXRhID0gKGltYWdlRGF0YSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB0ZXN0SW5wdXRzKG9wdGlvbnMpO1xuICB9XG4gIGNvbnN0IFtcbiAgICBfcGl4ZWxzLFxuICAgIF9kaXN0YW5jZSxcbiAgICBfY29sb3JWYWxpZGF0b3IsXG4gICAgX2h1ZURpc3RhbmNlLFxuICAgIF9zYXR1cmF0aW9uRGlzdGFuY2UsXG4gICAgX2xpZ2h0bmVzc0Rpc3RhbmNlXG4gIF0gPSBjbGVhbklucHV0cyhvcHRpb25zKTtcbiAgY29uc3QgeyBjb2xvcnMsIGNvdW50IH0gPSBleHRyYWN0b3IoXG4gICAgaW1hZ2VEYXRhLFxuICAgIF9waXhlbHMsXG4gICAgX2Rpc3RhbmNlLFxuICAgIF9jb2xvclZhbGlkYXRvclxuICApO1xuICByZXR1cm4gc29ydEZpbmFsQ29sb3JzKFxuICAgIGNvbG9ycyxcbiAgICBjb3VudCxcbiAgICBfaHVlRGlzdGFuY2UsXG4gICAgX3NhdHVyYXRpb25EaXN0YW5jZSxcbiAgICBfbGlnaHRuZXNzRGlzdGFuY2VcbiAgKTtcbn07XG5jb25zdCBleHRyYWN0Q29sb3JzRnJvbUltYWdlID0gYXN5bmMgKGltYWdlLCBvcHRpb25zID0ge30pID0+IHtcbiAgaWYgKGNoZWNrSXNOb2RlKCkpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiVXNlIGV4dHJhY3RDb2xvcnMgaW5zdGVhZCBleHRyYWN0Q29sb3JzRnJvbUltYWdlIGZvciBOb2RlLmpzXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdGVzdElucHV0cyhvcHRpb25zKTtcbiAgfVxuICBjb25zdCBbXG4gICAgX3BpeGVscyxcbiAgICBfZGlzdGFuY2UsXG4gICAgX2NvbG9yVmFsaWRhdG9yLFxuICAgIF9odWVEaXN0YW5jZSxcbiAgICBfc2F0dXJhdGlvbkRpc3RhbmNlLFxuICAgIF9saWdodG5lc3NEaXN0YW5jZSxcbiAgICBfY3Jvc3NPcmlnaW5cbiAgXSA9IGNsZWFuSW5wdXRzKG9wdGlvbnMpO1xuICBpbWFnZS5jcm9zc09yaWdpbiA9IF9jcm9zc09yaWdpbjtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgY29uc3QgZXh0cmFjdCA9IChpbWFnZTIpID0+IHtcbiAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGV4dHJhY3RJbWFnZURhdGEoaW1hZ2UyLCBfcGl4ZWxzKTtcbiAgICAgIGNvbnN0IHsgY29sb3JzLCBjb3VudCB9ID0gZXh0cmFjdG9yKFxuICAgICAgICBpbWFnZURhdGEsXG4gICAgICAgIF9waXhlbHMsXG4gICAgICAgIF9kaXN0YW5jZSxcbiAgICAgICAgX2NvbG9yVmFsaWRhdG9yXG4gICAgICApO1xuICAgICAgcmVzb2x2ZShcbiAgICAgICAgc29ydEZpbmFsQ29sb3JzKFxuICAgICAgICAgIGNvbG9ycyxcbiAgICAgICAgICBjb3VudCxcbiAgICAgICAgICBfaHVlRGlzdGFuY2UsXG4gICAgICAgICAgX3NhdHVyYXRpb25EaXN0YW5jZSxcbiAgICAgICAgICBfbGlnaHRuZXNzRGlzdGFuY2VcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9O1xuICAgIGlmIChpbWFnZS5jb21wbGV0ZSkge1xuICAgICAgZXh0cmFjdChpbWFnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGltYWdlTG9hZGVkID0gKCkgPT4ge1xuICAgICAgICBpbWFnZS5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLCBpbWFnZUxvYWRlZCk7XG4gICAgICAgIGV4dHJhY3QoaW1hZ2UpO1xuICAgICAgfTtcbiAgICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGltYWdlTG9hZGVkKTtcbiAgICB9XG4gIH0pO1xufTtcbmNvbnN0IGV4dHJhY3RDb2xvcnNGcm9tSW1hZ2VCaXRtYXAgPSBhc3luYyAoaW1hZ2UsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBpZiAoY2hlY2tJc05vZGUoKSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJVc2UgZXh0cmFjdENvbG9ycyBpbnN0ZWFkIGV4dHJhY3RDb2xvcnNGcm9tSW1hZ2VCaXRtYXAgZm9yIE5vZGUuanNcIlxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB0ZXN0SW5wdXRzKG9wdGlvbnMpO1xuICB9XG4gIGNvbnN0IFtcbiAgICBfcGl4ZWxzLFxuICAgIF9kaXN0YW5jZSxcbiAgICBfY29sb3JWYWxpZGF0b3IsXG4gICAgX2h1ZURpc3RhbmNlLFxuICAgIF9zYXR1cmF0aW9uRGlzdGFuY2UsXG4gICAgX2xpZ2h0bmVzc0Rpc3RhbmNlXG4gIF0gPSBjbGVhbklucHV0cyhvcHRpb25zKTtcbiAgY29uc3QgaW1hZ2VEYXRhID0gZXh0cmFjdEltYWdlRGF0YShpbWFnZSwgX3BpeGVscyk7XG4gIGNvbnN0IHsgY29sb3JzLCBjb3VudCB9ID0gZXh0cmFjdG9yKFxuICAgIGltYWdlRGF0YSxcbiAgICBfcGl4ZWxzLFxuICAgIF9kaXN0YW5jZSxcbiAgICBfY29sb3JWYWxpZGF0b3JcbiAgKTtcbiAgcmV0dXJuIHNvcnRGaW5hbENvbG9ycyhcbiAgICBjb2xvcnMsXG4gICAgY291bnQsXG4gICAgX2h1ZURpc3RhbmNlLFxuICAgIF9zYXR1cmF0aW9uRGlzdGFuY2UsXG4gICAgX2xpZ2h0bmVzc0Rpc3RhbmNlXG4gICk7XG59O1xuY29uc3QgZXh0cmFjdENvbG9yc0Zyb21TcmMgPSBhc3luYyAoc3JjLCBvcHRpb25zID0ge30pID0+IHtcbiAgaWYgKGNoZWNrSXNOb2RlKCkpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IHVzZSBleHRyYWN0Q29sb3JzRnJvbVNyYyBmb3IgTm9kZS5qc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB0ZXN0SW5wdXRzKG9wdGlvbnMpO1xuICB9XG4gIGlmIChjaGVja0lzV29ya2VyKCkpIHtcbiAgICBjb25zdCBpbnB1dHMgPSBjbGVhbklucHV0cyhvcHRpb25zKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHNyYywgeyBtb2RlOiBpbnB1dHNbN10gfSk7XG4gICAgY29uc3QgYmxvYiA9IGF3YWl0IHJlc3BvbnNlLmJsb2IoKTtcbiAgICBjb25zdCBiaXRtYXAgPSBhd2FpdCBjcmVhdGVJbWFnZUJpdG1hcChibG9iKTtcbiAgICBjb25zdCBjb2xvcnMgPSBhd2FpdCBleHRyYWN0Q29sb3JzRnJvbUltYWdlQml0bWFwKGJpdG1hcCwgb3B0aW9ucyk7XG4gICAgYml0bWFwLmNsb3NlKCk7XG4gICAgcmV0dXJuIGNvbG9ycztcbiAgfVxuICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICBpbWFnZS5zcmMgPSBzcmM7XG4gIHJldHVybiBleHRyYWN0Q29sb3JzRnJvbUltYWdlKGltYWdlLCBvcHRpb25zKTtcbn07XG5jb25zdCBleHRyYWN0Q29sb3JzID0gKHBpY3R1cmUsIG9wdGlvbnMpID0+IHtcbiAgaWYgKGNoZWNrSXNCcm93c2VyKCkpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBpZiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5yZXF1ZXN0TW9kZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJvcHRpb25zLnJlcXVlc3RNb2RlIG5vdCBzdXBwb3J0ZWQgaW4gQnJvd3NlciwgdXNlIG9wdGlvbnMuY3Jvc3NPcmlnaW4gaW5zdGVhZFwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwaWN0dXJlIGluc3RhbmNlb2YgSW1hZ2UpIHtcbiAgICAgIHJldHVybiBleHRyYWN0Q29sb3JzRnJvbUltYWdlKHBpY3R1cmUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAocGljdHVyZSBpbnN0YW5jZW9mIEltYWdlRGF0YSB8fCBwaWN0dXJlIGluc3RhbmNlb2YgT2JqZWN0ICYmIHBpY3R1cmUuZGF0YSkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHJlc29sdmUoZXh0cmFjdENvbG9yc0Zyb21JbWFnZURhdGEocGljdHVyZSwgb3B0aW9ucykpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcGljdHVyZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIGV4dHJhY3RDb2xvcnNGcm9tU3JjKHBpY3R1cmUsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuICBpZiAoY2hlY2tJc1dvcmtlcigpKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuY3Jvc3NPcmlnaW4pIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwib3B0aW9ucy5jcm9zc09yaWdpbiBub3Qgc3VwcG9ydGVkIGluIFdlYiBXb3JrZXIsIHVzZSBvcHRpb25zLnJlcXVlc3RNb2RlIGluc3RlYWRcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGljdHVyZSBpbnN0YW5jZW9mIEltYWdlRGF0YSB8fCBwaWN0dXJlIGluc3RhbmNlb2YgT2JqZWN0ICYmIHBpY3R1cmUuZGF0YSkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHJlc29sdmUoXG4gICAgICAgICAgZXh0cmFjdENvbG9yc0Zyb21JbWFnZURhdGEoXG4gICAgICAgICAgICBwaWN0dXJlLFxuICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHBpY3R1cmUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBleHRyYWN0Q29sb3JzRnJvbVNyYyhwaWN0dXJlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKHBpY3R1cmUuc3JjKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIkhUTUxJbWFnZUVsZW1lbnQgbm90IGVuYWJsZSBvbiB3b3JrZXIsIGEgZmFsbGJhY2sgaXMgdXNlZCB0byBleHRyYWN0IHNyYyBmcm9tIHlvdXIgSFRNTEltYWdlRWxlbWVudCwgcGxlYXNlIHNlbmQgJ3NyYycgaW5zdGVhZCBIVE1MSW1hZ2VFbGVtZW50XCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBleHRyYWN0Q29sb3JzRnJvbVNyYyhwaWN0dXJlLnNyYywgb3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIGlmIChjaGVja0lzTm9kZSgpKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgaWYgKHBpY3R1cmUgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiU2VuZCBpbWFnZURhdGEgdG8gZXh0cmFjdENvbG9ycyAoSW1hZ2Ugc3JjIG9yIEhUTUxJbWFnZUVsZW1lbnQgbm90IHN1cHBvcnRlZCBpbiBOb2RlanMpXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICghcGljdHVyZS5kYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlbmQgaW1hZ2VEYXRhIHRvIGV4dHJhY3RDb2xvcnNcIik7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5jcm9zc09yaWdpbikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJvcHRpb25zLmNyb3NzT3JpZ2luIG5vdCBzdXBwb3J0ZWQgaW4gTm9kZS5qc1wiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICByZXNvbHZlKFxuICAgICAgICBleHRyYWN0Q29sb3JzRnJvbUltYWdlRGF0YShwaWN0dXJlLCBvcHRpb25zKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYENhbiBub3QgYW5hbHlzZSBwaWN0dXJlYCk7XG59O1xuZXhwb3J0IHtcbiAgZXh0cmFjdENvbG9ycyxcbiAgZXh0cmFjdENvbG9yc0Zyb21JbWFnZSxcbiAgZXh0cmFjdENvbG9yc0Zyb21JbWFnZUJpdG1hcCxcbiAgZXh0cmFjdENvbG9yc0Zyb21JbWFnZURhdGEsXG4gIGV4dHJhY3RDb2xvcnNGcm9tU3JjXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXh0cmFjdC1jb2xvcnMubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/extract-colors/lib/extract-colors.mjs\n");

/***/ })

};
;