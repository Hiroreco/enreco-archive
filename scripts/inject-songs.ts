// scripts/inject-songs.ts
import fs from "fs/promises";
import path from "path";
import { parseFile } from "music-metadata";

async function formatDuration(seconds: number): Promise<string> {
    const mins = Math.floor(seconds / 60);
    const secs = Math.round(seconds % 60);
    return `${mins.toString().padStart(2, "0")}:${secs
        .toString()
        .padStart(2, "0")}`;
}

async function main() {
    const baseDir = path.resolve(
        process.cwd(),
        "apps",
        "website",
        "public-resources",
        "audio",
        "songs",
    );
    let categories: string[];
    try {
        categories = (await fs.readdir(baseDir, { withFileTypes: true }))
            .filter((d) => d.isDirectory())
            .map((d) => d.name);
    } catch {
        console.error(`Cannot read songs directory at ${baseDir}`);
        process.exit(1);
    }

    const result: Record<
        string,
        Array<{
            title: string;
            info: string;
            originalUrl: string;
            sourceUrl: string;
            coverUrl: string;
            duration: string;
        }>
    > = {};

    for (const category of categories) {
        const catDir = path.join(baseDir, category);
        const files = (await fs.readdir(catDir)).filter((f) =>
            f.toLowerCase().endsWith(".mp3"),
        );

        const songs: (typeof result)[string] = [];

        for (const file of files) {
            const fullPath = path.join(catDir, file);
            const name = path.basename(file, ".mp3");
            let durationStr = "00:00";

            try {
                const meta = await parseFile(fullPath);
                if (meta.format.duration) {
                    durationStr = await formatDuration(meta.format.duration);
                }
            } catch (err) {
                console.warn(
                    `Warning: could not read metadata for ${file}`,
                    err,
                );
            }

            songs.push({
                title: name,
                info: "",
                originalUrl: "",
                sourceUrl: `/audio/songs/${category}/${file}`,
                coverUrl: `/images-opt/song-${name}.webp`,
                duration: durationStr,
            });
        }

        result[category] = songs;
    }

    // Serialize to a TS file
    const outPath = path.resolve(process.cwd(), "src", "data", "songs.ts");
    const fileLines = [
        `// THIS FILE IS AUTO-GENERATED BY scripts/inject-songs.ts`,
        `export type Song = {`,
        `  title: string;`,
        `  info: string;`,
        `  originalUrl: string;`,
        `  sourceUrl: string;`,
        `  coverUrl: string;`,
        `  duration: string; // mm:ss`,
        `};`,
        ``,
        `export const SONGS: { [category: string]: Song[] } = `,
        JSON.stringify(result, null, 2).replace(
            /^/gm,
            "", // no indent
        ) + `;`,
        ``,
    ];

    await fs.mkdir(path.dirname(outPath), { recursive: true });
    await fs.writeFile(outPath, fileLines.join("\n"), "utf-8");
    console.log(`âœ… Injected songs data into ${outPath}`);
}

main().catch((err) => {
    console.error(err);
    process.exit(1);
});
